# node-golang-native-addon-experiment

This is a (very) simple experiment with writing native node modules with [Golang](https://golang.org)
and [node-gyp](https://github.com/node/node-gyp).

### Dependencies

To try this out, you will need to have `Go` and `node-gyp` installed. Of course, you will also need
`Node.js` installed.

### How it works

To start, we first take the a simple Go program that exposes functions via [cgo](https://golang.org/cmd/cgo/).
Using the `C` package, we can utilize the special `export` comment to tell the compiler that a function is going
to be exported.

**`lib/main.go`**
```go
package main

import "C"

//export Hello
func Hello () *C.char {
  return C.CString("Hello world!")
}

// required to build
func main () {}
```

**Note:** As you may have noticed, the function returns a C string instead of a regular Go string.
You can export a Go string, but this was a little easier to work with in the native code.

Now, we can build a shared library. We will export the shared object file as `libgo.so`. Doing this will
also export a `libgo.h` file, which we will need.

```bash
# in the lib directory
$ go build -buildmode=c-archive -o libgo.a
```

We build with the `c-archive` build mode because it links the library at compile time. Another option would be
to use the `c-shared` build mode, but depending on the platform, you may run into issues when attempting to run
the final script.

If you are adventurous and want to try out the `c-shared` build mode and happen to be using MacOS, you
might need to set the `DYLD_FALLBACK_LIBRARY_PATH` environment variable to include the project's `lib` directory.

Now, lets create the native code that will bridge our Go and Javascript.

**`goAddon.cc`**

```c++
#include <node.h>
// include the header file generated from the Go build
#include "lib/libgo.h"

using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::Object;
using v8::String;
using v8::Value;

void HelloMethod(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  // Call exported Go function, which returns a C string
  char *c = Hello();
  // return the value
  args.GetReturnValue().Set(String::NewFromUtf8(isolate, c));
  delete c;
}

// add method to exports
void init(Local<Object> exports) {
  NODE_SET_METHOD(exports, "hello", HelloMethod);
}

// create module
NODE_MODULE(myGoAddon, init)
```

As you can see, we can simply import the correct header and call the exported `Hello` function.

Now that we have all of the native components ready, we can link everything together in our `binding.gyp` file.

**`binding.gyp`**
```gyp
{
  'targets': [
    {
      'target_name': 'go-addon',
      # import all necessary source files
      'sources': [
        'lib/libgo.h', # this file was generated by go build
        'go-addon.cc'
      ],
      # libraries are relative to the 'build' directory
      'libraries': [ '../lib/libgo.a' ] # this file was also generated by go build
    }
  ]
}
```

Now that we have all of the native portions in place, we just need to compile our native code into something
that `node` can use.

```bash
# Generate appropriate build files for platform
$ node-gyp configure

# build the project to create our bindings file
$ node-gyp build
```

After this, you should see that that a `build` directory was created. If you take a peek into the directory,
you will see that we now have a `go-addon.node` file under the `build/Release` folder.

Finally, we can write some Javascript.

**`index.js`**
```js
const goAddon = require('./build/Release/go-addon');

console.log(goAddon.hello());
```

Now, we can run our script and see it output the string that our Go function returned.

```bash
$ node index.js
Hello world!
```

If you want to see in action, but don't want to go through the trouble of running the commands, you can run the
provided `run-build.sh` script to get everything working.

```bash
$ ./run-build.sh
```



