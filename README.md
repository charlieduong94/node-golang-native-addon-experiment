# node-golang-native-addon-experiment

This is a (very) simple experiment with writing native node modules with [Golang](https://golang.org)
and [node-gyp](https://github.com/node/node-gyp).

### Dependencies

To try this out, you will need to have `Go` and `node-gyp` installed. Of course, you will also need
`Node.js` installed.

### How it works

To start, we first take the a simple Go program that exposes functions via [cgo](https://golang.org/cmd/cgo/).
Using the `C` package, we can utilize the special `export` comment to tell the compiler that a function is going
to be exported.

**`lib/main.go`**
```go
package main

import "C"

//export Hello
func Hello () *C.char {
  return C.CString("Hello world!")
}

// required to build
func main () {}
```

**Note:** As you may have noticed, the function returns a C string instead of a regular Go string.
You can export a Go string, but this was a little easier to work with in the native code.

Now, we can build a shared library. We will export the shared object file as `libgo.so`. Doing this will
also export a `libgo.h` file, which we will need.

```bash
# in the lib directory
go build -buildmode=c-shared -o libgo.so
```

**`goAddon.cc`**
Now, lets create the native code that will bridge our Go and Javascript.

```c++
#include <node.h>
// include the header file generated from the Go build
#include "./lib/libgo.h"

using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::Object;
using v8::String;
using v8::Value;

void Method(const v8::FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  // Call exported Go function, which returns a C string
  char *c = Hello();
  // return the value
  args.GetReturnValue().Set(String::NewFromUtf8(isolate, c));
  delete c;
}

// add method to exports
void init(Local<Object> exports) {
  NODE_SET_METHOD(exports, "hello", Method);
}

// create module
NODE_MODULE(myGoAddon, init)
```

As you can see, we can simply import the correct header and call the exported `Hello` function.

Now that we have all of the native components ready, we can link everything together in our `binding.gyp` file.

Let's edit the `gyp` file to include our sources.

**`binding.gyp`**
```gyp
{
  'targets': [
    {
      'target_name': 'go-addon',
      # import all necessary source files
      'sources': [
        './lib/libgo.h', # this file was generated by go build
        'go-addon.cc'
      ],
      # libraries are relative to the 'build' directory
      'libraries': [ '../lib/libgo.so' ] # this file was also generated by go build
    }
  ]
}
```

Now that we have all of the native portions in place, we just need to compile our native code into something
that `node` can use.

```bash
# Generate appropriate build files for platform
node-gyp configure

# build the project to create our bindings file
node-gyp build
```

After this, you should see that that a `build` directory was created. If you take a peek into the directory,
you will see that we now have a `go-addon.node` file under the `build/Release` folder.

Finally, we can write some Javascript.

**`binding.gyp`**
```js
const goAddon = require('./build/Release/go-addon');

console.log(goAddon.hello());
```

Now, we can run our script and see it output "Hello world!".

```bash
node index.js
```

**Note:** If you are running on MacOS like I am, you might need to set the `DYLD_FALLBACK_LIBRARY_PATH`
environment variable to include the location of the `libgo.so` file before running the node script. From
the root of this project you can just run following in your terminal:

```bash
export DYLD_FALLBACK_LIBRARY_PATH="./lib:$DYLD_FALLBACK_LIBRARY_PATH"
```

If you want to see in action, but don't want to go through the trouble of running the commands, you can run
the following command to build everything for you.

```bash
# source the script so that the environment variable has the lib path
. ./run-build.sh
```



